// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name,long_type_number,force_client_none,server_none
// @generated from protobuf file "stream/stream.proto" (package "stream", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message stream.ShioajiEvent
 */
export interface ShioajiEvent {
    /**
     * @generated from protobuf field: int64 resp_code = 1
     */
    resp_code: number;
    /**
     * @generated from protobuf field: int64 event_code = 2
     */
    event_code: number;
    /**
     * @generated from protobuf field: string info = 3
     */
    info: string;
    /**
     * @generated from protobuf field: string event = 4
     */
    event: string;
    /**
     * @generated from protobuf field: string event_time = 5
     */
    event_time: string;
}
/**
 * @generated from protobuf message stream.SubscribeFutureTickRequest
 */
export interface SubscribeFutureTickRequest {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
}
/**
 * @generated from protobuf message stream.FutureTick
 */
export interface FutureTick {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: string date_time = 2
     */
    date_time: string;
    /**
     * @generated from protobuf field: double open = 3
     */
    open: number;
    /**
     * @generated from protobuf field: double underlying_price = 4
     */
    underlying_price: number;
    /**
     * @generated from protobuf field: int64 bid_side_total_vol = 5
     */
    bid_side_total_vol: number;
    /**
     * @generated from protobuf field: int64 ask_side_total_vol = 6
     */
    ask_side_total_vol: number;
    /**
     * @generated from protobuf field: double avg_price = 7
     */
    avg_price: number;
    /**
     * @generated from protobuf field: double close = 8
     */
    close: number;
    /**
     * @generated from protobuf field: double high = 9
     */
    high: number;
    /**
     * @generated from protobuf field: double low = 10
     */
    low: number;
    /**
     * @generated from protobuf field: double amount = 11
     */
    amount: number;
    /**
     * @generated from protobuf field: double total_amount = 12
     */
    total_amount: number;
    /**
     * @generated from protobuf field: int64 volume = 13
     */
    volume: number;
    /**
     * @generated from protobuf field: int64 total_volume = 14
     */
    total_volume: number;
    /**
     * @generated from protobuf field: int64 tick_type = 15
     */
    tick_type: number;
    /**
     * @generated from protobuf field: int64 chg_type = 16
     */
    chg_type: number;
    /**
     * @generated from protobuf field: double price_chg = 17
     */
    price_chg: number;
    /**
     * @generated from protobuf field: double pct_chg = 18
     */
    pct_chg: number;
    /**
     * @generated from protobuf field: bool simtrade = 19
     */
    simtrade: boolean;
}
/**
 * @generated from protobuf message stream.FutureBidAsk
 */
export interface FutureBidAsk {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: string date_time = 2
     */
    date_time: string;
    /**
     * @generated from protobuf field: int64 bid_total_vol = 3
     */
    bid_total_vol: number;
    /**
     * @generated from protobuf field: int64 ask_total_vol = 4
     */
    ask_total_vol: number;
    /**
     * @generated from protobuf field: repeated double bid_price = 5
     */
    bid_price: number[];
    /**
     * @generated from protobuf field: repeated int64 bid_volume = 6
     */
    bid_volume: number[];
    /**
     * @generated from protobuf field: repeated int64 diff_bid_vol = 7
     */
    diff_bid_vol: number[];
    /**
     * @generated from protobuf field: repeated double ask_price = 8
     */
    ask_price: number[];
    /**
     * @generated from protobuf field: repeated int64 ask_volume = 9
     */
    ask_volume: number[];
    /**
     * @generated from protobuf field: repeated int64 diff_ask_vol = 10
     */
    diff_ask_vol: number[];
    /**
     * @generated from protobuf field: double first_derived_bid_price = 11
     */
    first_derived_bid_price: number;
    /**
     * @generated from protobuf field: double first_derived_ask_price = 12
     */
    first_derived_ask_price: number;
    /**
     * @generated from protobuf field: int64 first_derived_bid_vol = 13
     */
    first_derived_bid_vol: number;
    /**
     * @generated from protobuf field: int64 first_derived_ask_vol = 14
     */
    first_derived_ask_vol: number;
    /**
     * @generated from protobuf field: double underlying_price = 15
     */
    underlying_price: number;
    /**
     * @generated from protobuf field: bool simtrade = 16
     */
    simtrade: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class ShioajiEvent$Type extends MessageType<ShioajiEvent> {
    constructor() {
        super("stream.ShioajiEvent", [
            { no: 1, name: "resp_code", kind: "scalar", localName: "resp_code", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "event_code", kind: "scalar", localName: "event_code", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "event_time", kind: "scalar", localName: "event_time", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShioajiEvent>): ShioajiEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resp_code = 0;
        message.event_code = 0;
        message.info = "";
        message.event = "";
        message.event_time = "";
        if (value !== undefined)
            reflectionMergePartial<ShioajiEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShioajiEvent): ShioajiEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 resp_code */ 1:
                    message.resp_code = reader.int64().toNumber();
                    break;
                case /* int64 event_code */ 2:
                    message.event_code = reader.int64().toNumber();
                    break;
                case /* string info */ 3:
                    message.info = reader.string();
                    break;
                case /* string event */ 4:
                    message.event = reader.string();
                    break;
                case /* string event_time */ 5:
                    message.event_time = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShioajiEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 resp_code = 1; */
        if (message.resp_code !== 0)
            writer.tag(1, WireType.Varint).int64(message.resp_code);
        /* int64 event_code = 2; */
        if (message.event_code !== 0)
            writer.tag(2, WireType.Varint).int64(message.event_code);
        /* string info = 3; */
        if (message.info !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.info);
        /* string event = 4; */
        if (message.event !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.event);
        /* string event_time = 5; */
        if (message.event_time !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.event_time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.ShioajiEvent
 */
export const ShioajiEvent = new ShioajiEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeFutureTickRequest$Type extends MessageType<SubscribeFutureTickRequest> {
    constructor() {
        super("stream.SubscribeFutureTickRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeFutureTickRequest>): SubscribeFutureTickRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        if (value !== undefined)
            reflectionMergePartial<SubscribeFutureTickRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeFutureTickRequest): SubscribeFutureTickRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeFutureTickRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.SubscribeFutureTickRequest
 */
export const SubscribeFutureTickRequest = new SubscribeFutureTickRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FutureTick$Type extends MessageType<FutureTick> {
    constructor() {
        super("stream.FutureTick", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "date_time", kind: "scalar", localName: "date_time", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "open", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "underlying_price", kind: "scalar", localName: "underlying_price", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "bid_side_total_vol", kind: "scalar", localName: "bid_side_total_vol", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "ask_side_total_vol", kind: "scalar", localName: "ask_side_total_vol", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 7, name: "avg_price", kind: "scalar", localName: "avg_price", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "close", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "high", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "low", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "total_amount", kind: "scalar", localName: "total_amount", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "volume", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 14, name: "total_volume", kind: "scalar", localName: "total_volume", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 15, name: "tick_type", kind: "scalar", localName: "tick_type", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 16, name: "chg_type", kind: "scalar", localName: "chg_type", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 17, name: "price_chg", kind: "scalar", localName: "price_chg", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "pct_chg", kind: "scalar", localName: "pct_chg", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 19, name: "simtrade", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FutureTick>): FutureTick {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.date_time = "";
        message.open = 0;
        message.underlying_price = 0;
        message.bid_side_total_vol = 0;
        message.ask_side_total_vol = 0;
        message.avg_price = 0;
        message.close = 0;
        message.high = 0;
        message.low = 0;
        message.amount = 0;
        message.total_amount = 0;
        message.volume = 0;
        message.total_volume = 0;
        message.tick_type = 0;
        message.chg_type = 0;
        message.price_chg = 0;
        message.pct_chg = 0;
        message.simtrade = false;
        if (value !== undefined)
            reflectionMergePartial<FutureTick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FutureTick): FutureTick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string date_time */ 2:
                    message.date_time = reader.string();
                    break;
                case /* double open */ 3:
                    message.open = reader.double();
                    break;
                case /* double underlying_price */ 4:
                    message.underlying_price = reader.double();
                    break;
                case /* int64 bid_side_total_vol */ 5:
                    message.bid_side_total_vol = reader.int64().toNumber();
                    break;
                case /* int64 ask_side_total_vol */ 6:
                    message.ask_side_total_vol = reader.int64().toNumber();
                    break;
                case /* double avg_price */ 7:
                    message.avg_price = reader.double();
                    break;
                case /* double close */ 8:
                    message.close = reader.double();
                    break;
                case /* double high */ 9:
                    message.high = reader.double();
                    break;
                case /* double low */ 10:
                    message.low = reader.double();
                    break;
                case /* double amount */ 11:
                    message.amount = reader.double();
                    break;
                case /* double total_amount */ 12:
                    message.total_amount = reader.double();
                    break;
                case /* int64 volume */ 13:
                    message.volume = reader.int64().toNumber();
                    break;
                case /* int64 total_volume */ 14:
                    message.total_volume = reader.int64().toNumber();
                    break;
                case /* int64 tick_type */ 15:
                    message.tick_type = reader.int64().toNumber();
                    break;
                case /* int64 chg_type */ 16:
                    message.chg_type = reader.int64().toNumber();
                    break;
                case /* double price_chg */ 17:
                    message.price_chg = reader.double();
                    break;
                case /* double pct_chg */ 18:
                    message.pct_chg = reader.double();
                    break;
                case /* bool simtrade */ 19:
                    message.simtrade = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FutureTick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string date_time = 2; */
        if (message.date_time !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.date_time);
        /* double open = 3; */
        if (message.open !== 0)
            writer.tag(3, WireType.Bit64).double(message.open);
        /* double underlying_price = 4; */
        if (message.underlying_price !== 0)
            writer.tag(4, WireType.Bit64).double(message.underlying_price);
        /* int64 bid_side_total_vol = 5; */
        if (message.bid_side_total_vol !== 0)
            writer.tag(5, WireType.Varint).int64(message.bid_side_total_vol);
        /* int64 ask_side_total_vol = 6; */
        if (message.ask_side_total_vol !== 0)
            writer.tag(6, WireType.Varint).int64(message.ask_side_total_vol);
        /* double avg_price = 7; */
        if (message.avg_price !== 0)
            writer.tag(7, WireType.Bit64).double(message.avg_price);
        /* double close = 8; */
        if (message.close !== 0)
            writer.tag(8, WireType.Bit64).double(message.close);
        /* double high = 9; */
        if (message.high !== 0)
            writer.tag(9, WireType.Bit64).double(message.high);
        /* double low = 10; */
        if (message.low !== 0)
            writer.tag(10, WireType.Bit64).double(message.low);
        /* double amount = 11; */
        if (message.amount !== 0)
            writer.tag(11, WireType.Bit64).double(message.amount);
        /* double total_amount = 12; */
        if (message.total_amount !== 0)
            writer.tag(12, WireType.Bit64).double(message.total_amount);
        /* int64 volume = 13; */
        if (message.volume !== 0)
            writer.tag(13, WireType.Varint).int64(message.volume);
        /* int64 total_volume = 14; */
        if (message.total_volume !== 0)
            writer.tag(14, WireType.Varint).int64(message.total_volume);
        /* int64 tick_type = 15; */
        if (message.tick_type !== 0)
            writer.tag(15, WireType.Varint).int64(message.tick_type);
        /* int64 chg_type = 16; */
        if (message.chg_type !== 0)
            writer.tag(16, WireType.Varint).int64(message.chg_type);
        /* double price_chg = 17; */
        if (message.price_chg !== 0)
            writer.tag(17, WireType.Bit64).double(message.price_chg);
        /* double pct_chg = 18; */
        if (message.pct_chg !== 0)
            writer.tag(18, WireType.Bit64).double(message.pct_chg);
        /* bool simtrade = 19; */
        if (message.simtrade !== false)
            writer.tag(19, WireType.Varint).bool(message.simtrade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.FutureTick
 */
export const FutureTick = new FutureTick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FutureBidAsk$Type extends MessageType<FutureBidAsk> {
    constructor() {
        super("stream.FutureBidAsk", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "date_time", kind: "scalar", localName: "date_time", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bid_total_vol", kind: "scalar", localName: "bid_total_vol", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "ask_total_vol", kind: "scalar", localName: "ask_total_vol", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "bid_price", kind: "scalar", localName: "bid_price", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "bid_volume", kind: "scalar", localName: "bid_volume", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 7, name: "diff_bid_vol", kind: "scalar", localName: "diff_bid_vol", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 8, name: "ask_price", kind: "scalar", localName: "ask_price", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "ask_volume", kind: "scalar", localName: "ask_volume", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 10, name: "diff_ask_vol", kind: "scalar", localName: "diff_ask_vol", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 11, name: "first_derived_bid_price", kind: "scalar", localName: "first_derived_bid_price", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "first_derived_ask_price", kind: "scalar", localName: "first_derived_ask_price", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "first_derived_bid_vol", kind: "scalar", localName: "first_derived_bid_vol", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 14, name: "first_derived_ask_vol", kind: "scalar", localName: "first_derived_ask_vol", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 15, name: "underlying_price", kind: "scalar", localName: "underlying_price", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "simtrade", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FutureBidAsk>): FutureBidAsk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.date_time = "";
        message.bid_total_vol = 0;
        message.ask_total_vol = 0;
        message.bid_price = [];
        message.bid_volume = [];
        message.diff_bid_vol = [];
        message.ask_price = [];
        message.ask_volume = [];
        message.diff_ask_vol = [];
        message.first_derived_bid_price = 0;
        message.first_derived_ask_price = 0;
        message.first_derived_bid_vol = 0;
        message.first_derived_ask_vol = 0;
        message.underlying_price = 0;
        message.simtrade = false;
        if (value !== undefined)
            reflectionMergePartial<FutureBidAsk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FutureBidAsk): FutureBidAsk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string date_time */ 2:
                    message.date_time = reader.string();
                    break;
                case /* int64 bid_total_vol */ 3:
                    message.bid_total_vol = reader.int64().toNumber();
                    break;
                case /* int64 ask_total_vol */ 4:
                    message.ask_total_vol = reader.int64().toNumber();
                    break;
                case /* repeated double bid_price */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bid_price.push(reader.double());
                    else
                        message.bid_price.push(reader.double());
                    break;
                case /* repeated int64 bid_volume */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bid_volume.push(reader.int64().toNumber());
                    else
                        message.bid_volume.push(reader.int64().toNumber());
                    break;
                case /* repeated int64 diff_bid_vol */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diff_bid_vol.push(reader.int64().toNumber());
                    else
                        message.diff_bid_vol.push(reader.int64().toNumber());
                    break;
                case /* repeated double ask_price */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ask_price.push(reader.double());
                    else
                        message.ask_price.push(reader.double());
                    break;
                case /* repeated int64 ask_volume */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ask_volume.push(reader.int64().toNumber());
                    else
                        message.ask_volume.push(reader.int64().toNumber());
                    break;
                case /* repeated int64 diff_ask_vol */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diff_ask_vol.push(reader.int64().toNumber());
                    else
                        message.diff_ask_vol.push(reader.int64().toNumber());
                    break;
                case /* double first_derived_bid_price */ 11:
                    message.first_derived_bid_price = reader.double();
                    break;
                case /* double first_derived_ask_price */ 12:
                    message.first_derived_ask_price = reader.double();
                    break;
                case /* int64 first_derived_bid_vol */ 13:
                    message.first_derived_bid_vol = reader.int64().toNumber();
                    break;
                case /* int64 first_derived_ask_vol */ 14:
                    message.first_derived_ask_vol = reader.int64().toNumber();
                    break;
                case /* double underlying_price */ 15:
                    message.underlying_price = reader.double();
                    break;
                case /* bool simtrade */ 16:
                    message.simtrade = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FutureBidAsk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string date_time = 2; */
        if (message.date_time !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.date_time);
        /* int64 bid_total_vol = 3; */
        if (message.bid_total_vol !== 0)
            writer.tag(3, WireType.Varint).int64(message.bid_total_vol);
        /* int64 ask_total_vol = 4; */
        if (message.ask_total_vol !== 0)
            writer.tag(4, WireType.Varint).int64(message.ask_total_vol);
        /* repeated double bid_price = 5; */
        if (message.bid_price.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bid_price.length; i++)
                writer.double(message.bid_price[i]);
            writer.join();
        }
        /* repeated int64 bid_volume = 6; */
        if (message.bid_volume.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bid_volume.length; i++)
                writer.int64(message.bid_volume[i]);
            writer.join();
        }
        /* repeated int64 diff_bid_vol = 7; */
        if (message.diff_bid_vol.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diff_bid_vol.length; i++)
                writer.int64(message.diff_bid_vol[i]);
            writer.join();
        }
        /* repeated double ask_price = 8; */
        if (message.ask_price.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ask_price.length; i++)
                writer.double(message.ask_price[i]);
            writer.join();
        }
        /* repeated int64 ask_volume = 9; */
        if (message.ask_volume.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ask_volume.length; i++)
                writer.int64(message.ask_volume[i]);
            writer.join();
        }
        /* repeated int64 diff_ask_vol = 10; */
        if (message.diff_ask_vol.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diff_ask_vol.length; i++)
                writer.int64(message.diff_ask_vol[i]);
            writer.join();
        }
        /* double first_derived_bid_price = 11; */
        if (message.first_derived_bid_price !== 0)
            writer.tag(11, WireType.Bit64).double(message.first_derived_bid_price);
        /* double first_derived_ask_price = 12; */
        if (message.first_derived_ask_price !== 0)
            writer.tag(12, WireType.Bit64).double(message.first_derived_ask_price);
        /* int64 first_derived_bid_vol = 13; */
        if (message.first_derived_bid_vol !== 0)
            writer.tag(13, WireType.Varint).int64(message.first_derived_bid_vol);
        /* int64 first_derived_ask_vol = 14; */
        if (message.first_derived_ask_vol !== 0)
            writer.tag(14, WireType.Varint).int64(message.first_derived_ask_vol);
        /* double underlying_price = 15; */
        if (message.underlying_price !== 0)
            writer.tag(15, WireType.Bit64).double(message.underlying_price);
        /* bool simtrade = 16; */
        if (message.simtrade !== false)
            writer.tag(16, WireType.Varint).bool(message.simtrade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.FutureBidAsk
 */
export const FutureBidAsk = new FutureBidAsk$Type();
/**
 * @generated ServiceType for protobuf service stream.StreamInterface
 */
export const StreamInterface = new ServiceType("stream.StreamInterface", [
    { name: "SubscribeFutureTick", serverStreaming: true, options: {}, I: SubscribeFutureTickRequest, O: FutureTick }
]);
